from html.parser import HTMLParser
import re

class HTMLconverter(HTMLParser):
    """
    Class to convert HTML to Python Dictionary.
    
    Usage:
    1. Construct an instance:
    ```Python
    converter = HTMLconverter()
    ```
    
    2. Turn your data into a list of lines with line breaks removed:
    ```Python
    with open('example.html') as f:
        data = f.readlines()
    transformed_data = [line[:-1] for line in data]
    ```
    
    3. Call ```convert```:
    ```Python
    converted_dictionary = converter.convert(transformed_data)
    ```
    """
    
    # def __init__(self, parse_chrome_bookmark=False):
    def __init__(self):
        super().__init__()
        self.converted_data = {'tag_info': ('root', []), 'data': [], 'children': []}
        self.stack = [self.converted_data]
        
        # self.parse_chrome_bookmark = parse_chrome_bookmark
    
    def handle_starttag(self, tag, attrs):
        super().handle_starttag(tag, attrs)
        
        new_dict = {'tag_info': (tag, attrs), 'data': [], 'children': []}
        self.stack[-1]['children'].append(new_dict)
        self.stack.append(new_dict)
        
    def handle_endtag(self, tag: str):
        super().handle_endtag(tag)
        
        stack_top_dict = self.stack.pop()
        if tag != stack_top_dict['tag_info'][0]:
            raise RuntimeError(f"Tag mismatch: current({tag}) != parent({stack_top_dict['tag_info'][0]})")

        # if self.parse_chrome_bookmark and (tag == 'a' or tag == 'h3'):
        #     assert self.stack[-1]['tag_info'][0] == 'dt'
        #     self.stack.pop()
            
    def handle_data(self, data: str):
        super().handle_data(data)
        
        self.stack[-1]['data'].append(data)
    
    def _terminate(self):
        ret = self.converted_data
        self.__init__()
        return ret
    
    def convert(self, data: list):
        for line in data:
            self.feed(line)
        return self._terminate()
        
def standardize_chrome_bookmark_html(data: str):
    """
    Reads in the html of bookmarks exported by Google Chrome,
    fixes the errors in the html that would hinder the parsing
    of html data, and returns the fixed html as a string.
    """
    
    replaced = data.replace('</H3>', '</H3></DT>')\
        .replace('</A>', '</A></DT>')\
        .replace('</DL><p>', '</p></DL>')
    return re.sub(r'(<META[^>]*>)', r'\1</META>', replaced)

def _chrome_bookmark_html_to_dict(data: dict):
    bookmark_list = data['children'][0]['children']
    converted_data = []
    i = 0
    while i < len(bookmark_list):
        tag = bookmark_list[i]['children'][0]['tag_info'][0]
        if tag == 'a':
            attrs = bookmark_list[i]['children'][0]['tag_info'][1]
            converted_data.append(('bookmark',
                                   bookmark_list[i]['children'][0]['data'][0],
                                   attrs[0][1]))
        elif tag == 'h3':
            converted_data.append(('data',
                                   bookmark_list[i]['children'][0]['data'][0],
                                   _chrome_bookmark_html_to_dict(bookmark_list[i + 1])))
            i += 1
        else:
            raise RuntimeError(f"Unrecognized tag: {tag}")
        
        i += 1
    
    return converted_data

def _convert_chrome_bookmark_raw_html_dict(data: dict):
    return _chrome_bookmark_html_to_dict(data['children'][3])

def parse_chrome_bookmarks(data: list):
    """
    Reads in the html file generated by exporting Google Chrome
    bookmarks, and returns a list of bookmarks, preserving the
    directory structure.
    """
    
    return _convert_chrome_bookmark_raw_html_dict(
        HTMLconverter().convert(
            [standardize_chrome_bookmark_html(line) for line in data]))

def _generate_latex_from_bookmarks_recursive(bookmarks: list, indent: int=1):
    output = ''
    
    for t, name, data in bookmarks:
        if t == 'bookmark':
            output += '\t' * indent + r'\item ' + f'\\href{{{data}}}{{{name}}}' + '\n'
        elif t == 'data':
            output += '\t' * (indent - 1) + r'\item' + '\n'
            output += '\t' * indent + name + ':' + '\n'
            output += '\t' * indent + r'\begin{enumerate}' + '\n'
            
            output += _generate_latex_from_bookmarks_recursive(data, indent + 1)
            
            output += '\t' * indent + r'\end{enumerate}' + '\n'
        else:
            raise ValueError(f'Unrecognized type: {t}')
    
    return output

def _find_root_in_bookmarks(bookmarks: list, root: str):
    for item in bookmarks:
        if item[1] == root:
            return [item]
        
        if item[0] == 'data':
            res = _find_root_in_bookmarks(item[2], root)
            if res is not None:
                return res
            
    return None

def generate_latex_from_bookmarks(bookmarks: list, root: str=''):
    """
    Generates latex from converted Google Chrome bookmarks
    returned by parse_chrome_bookmark. root specifies which
    folder of bookmarks to generate latex.
    """
    if root != '':
        bookmarks = _find_root_in_bookmarks(bookmarks, root)
        
        if bookmarks is None:
            raise RuntimeError(f'Failed to find an item named {root}')
        
    return r'\begin{enumerate}' + '\n' \
        + _generate_latex_from_bookmarks_recursive(bookmarks, 1) \
        + r'\end{enumerate}' + '\n'